package date.API_one;
/**
 * Другой важный момент в java.util.Calendar состоит в том,
 * что при установке в нем полной даты (yyyy,MM,dd,HH,mm,ss)
 * количество миллисекунд не сбрасывается в 0, а остается равным
 * количеству миллисекунд от предыдущего установленного момента
 * (текущего времени, если календарь не менялся).
 * оэтому, если по условиям задачи в миллисекундах должно быть 0,
 * то это поле нужно сбросить еще одним дополнительным вызовом
 *
 * java.text.DateFormat и java.util.Calendar обязательно нужно сказать следующее:
 У обоих классов есть метод setTimezone() для явной установки временной зоны.
 Крайне желательно всегда его использовать для того, чтобы обозначить,
 что вы полностью контролируете процесс, а не полагаетесь на временную зону по-умолчанию.

 У обоих классов есть метод setLenient() для установки «мягкого» режима.
 В таком режиме оба класса будут снисходительно относиться к ошибкам в
 календарных метках, пытаясь угадать что же вы имели в виду на самом деле.
 Тут зависит от ситуации, но я бы рекомендовал угадывание отключать
 (по умолчанию «мягкий» режим включен).

 Оба класса потоко-небезопасны. И, если для java.util.Calendar это совершенно ожидаемо
 (поскольку мы понимаем что у него есть внутреннее состояние),
 то, в случае java.text.DateFormat, это для многих оказывается сюрпризом.
 */